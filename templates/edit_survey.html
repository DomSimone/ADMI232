{% extends "base.html" %}

{% block title %}Edit Survey: {{ survey.title }}{% endblock %}

{% block head_extra %}
<style>
    /* Specific styles for edit_survey page */
    .survey-details {
        background-color: #f0f8ff;
        border: 1px solid #b0e0e6;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
    }
    .question-list {
        margin-top: 20px;
        border-top: 1px solid #eee;
        padding-top: 20px;
    }
    .question-item {
        background-color: #f9f9f9;
        border: 1px solid #ddd;
        padding: 15px;
        margin-bottom: 15px;
        border-radius: 8px;
        position: relative;
        cursor: grab;
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }
    .question-item.dragging {
        opacity: 0.5;
        border: 2px dashed #007bff;
    }
    .question-item h3 {
        margin-top: 0;
        color: #555;
    }
    .question-item .actions {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        gap: 5px;
    }
    .question-item .actions button {
        padding: 5px 10px;
        font-size: 0.8em;
        border-radius: 4px;
    }
    .add-question-form {
        background-color: #e6ffe6;
        border: 1px solid #aaffaa;
        padding: 20px;
        border-radius: 8px;
        margin-top: 30px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }
    .add-question-form div {
        margin-bottom: 15px;
    }
    .options-container {
        margin-top: 10px;
        padding-left: 20px;
        border-left: 2px solid #eee;
    }
    .back-link {
        display: block;
        margin-top: 20px;
        text-align: center;
    }
</style>
{% endblock %}

{% block content %}
    <div class="container">
        <h1>Edit Survey: {{ survey.title }}</h1>
        <div class="survey-details section">
            <p><strong>ID:</strong> {{ survey.id }}</p>
            <p><strong>Description:</strong> {{ survey.description }}</p>
        </div>

        <h2>Questions (Drag to Reorder)</h2>
        <div id="question-list" class="question-list section">
            {% if survey.questions %}
                {% for question in survey.questions %}
                    <div class="question-item" draggable="true" data-question-id="{{ question.id }}">
                        <h3>{{ loop.index }}. {{ question.text }} ({{ question.type }})</h3>
                        <p><strong>Validation:</strong> {{ question.get_validation_dict() | tojson }}</p>
                        {% if question.options %}
                            <p><strong>Options:</strong> {{ question.get_options_list() | join(', ') }}</p>
                        {% endif %}
                        {% if question.branching_logic %}
                            <p><strong>Branching Logic:</strong> {{ question.get_branching_logic_dict() | tojson }}</p>
                        {% endif %}
                        <div class="actions">
                            <button class="button-secondary" onclick="editQuestion({{ question.id }})">Edit</button>
                            <button class="button-danger" onclick="deleteQuestion(this, {{ question.id }})">Delete</button>
                        </div>
                    </div>
                {% endfor %}
            {% else %}
                <p>No questions added yet. Use the form below to add your first question.</p>
            {% endif %}
        </div>

        <div class="add-question-form section">
            <h2><span id="formTitle">Add New Question</span></h2>
            <div>
                <label for="questionText">Question Text:</label>
                <input type="text" id="questionText" required>
            </div>
            <div>
                <label for="questionType">Question Type:</label>
                <select id="questionType" onchange="toggleOptionsInput()">
                    <option value="text">Text Input</option>
                    <option value="number">Number Input</option>
                    <option value="multiple_choice">Multiple Choice</option>
                    <option value="checkbox">Checkbox</option>
                    <option value="date">Date</option>
                </select>
            </div>
            <div id="optionsSection" class="options-container" style="display: none;">
                <label>Options (one per line):</label>
                <textarea id="questionOptions" rows="4"></textarea>
            </div>
            <div>
                <label for="validationRules">Validation Rules (JSON format, e.g., {"required": true, "min_length": 5}):</label>
                <textarea id="validationRules" rows="2">{}</textarea>
            </div>
            <div>
                <label for="branchingLogic">Branching Logic (JSON format, e.g., {"if_answer": "Yes", "show_question_id": 5}):</label>
                <textarea id="branchingLogic" rows="2">{}</textarea>
            </div>
            <button id="submitQuestionBtn" class="button-primary" onclick="handleQuestionSubmit()">Add Question</button>
            <button id="cancelEditBtn" class="button-secondary" onclick="cancelEdit()" style="display:none;">Cancel Edit</button>
        </div>

        <a href="{{ url_for('survey_list') }}" class="button-link">Back to Survey List</a>
    </div>
{% endblock %}

{% block scripts %}
    <script>
        const surveyId = {{ survey.id }};
        const questionListDiv = document.getElementById('question-list');
        let editingQuestionId = null; // To keep track of the question being edited

        const questionTextElem = document.getElementById('questionText');
        const questionTypeElem = document.getElementById('questionType');
        const questionOptionsElem = document.getElementById('questionOptions');
        const validationRulesElem = document.getElementById('validationRules');
        const branchingLogicElem = document.getElementById('branchingLogic');
        const optionsSectionElem = document.getElementById('optionsSection');
        const formTitleElem = document.getElementById('formTitle');
        const submitQuestionBtn = document.getElementById('submitQuestionBtn');
        const cancelEditBtn = document.getElementById('cancelEditBtn');


        function toggleOptionsInput() {
            const questionType = questionTypeElem.value;
            if (questionType === 'multiple_choice' || questionType === 'checkbox') {
                optionsSectionElem.style.display = 'block';
            } else {
                optionsSectionElem.style.display = 'none';
            }
        }

        function resetForm() {
            editingQuestionId = null;
            questionTextElem.value = '';
            questionTypeElem.value = 'text';
            questionOptionsElem.value = '';
            validationRulesElem.value = '{}';
            branchingLogicElem.value = '{}';
            toggleOptionsInput(); // Reset options visibility
            formTitleElem.textContent = 'Add New Question';
            submitQuestionBtn.textContent = 'Add Question';
            cancelEditBtn.style.display = 'none';
        }

        async function handleQuestionSubmit() {
            const questionText = questionTextElem.value;
            const questionType = questionTypeElem.value;
            const questionOptions = questionOptionsElem.value;
            const validationRules = validationRulesElem.value;
            const branchingLogic = branchingLogicElem.value;

            if (!questionText) {
                alert('Question text cannot be empty.');
                return;
            }

            let optionsArray = [];
            if (questionType === 'multiple_choice' || questionType === 'checkbox') {
                optionsArray = questionOptions.split('\n').map(opt => opt.trim()).filter(opt => opt !== '');
                if (optionsArray.length === 0) {
                    alert('Please add at least one option for Multiple Choice/Checkbox questions.');
                    return;
                }
            }

            let parsedValidation = {};
            try {
                parsedValidation = JSON.parse(validationRules);
            } catch (e) {
                alert('Invalid JSON for Validation Rules.');
                return;
            }

            let parsedBranchingLogic = {};
            try {
                parsedBranchingLogic = JSON.parse(branchingLogic);
            } catch (e) {
                alert('Invalid JSON for Branching Logic.');
                return;
            }

            const method = editingQuestionId ? 'PUT' : 'POST';
            const url = editingQuestionId ? `/api/surveys/${surveyId}/questions/${editingQuestionId}` : `/api/surveys/${surveyId}/questions`;

            const response = await fetch(url, {
                method: method,
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    question_text: questionText,
                    question_type: questionType,
                    options: optionsArray,
                    validation: parsedValidation,
                    branching_logic: parsedBranchingLogic
                }),
            });

            if (response.ok) {
                const updatedQuestion = await response.json();
                alert('Question ' + (editingQuestionId ? 'updated' : 'added') + ' successfully!');
                
                // Update or add the question in the DOM
                if (editingQuestionId) {
                    const existingQuestionItem = document.querySelector(`.question-item[data-question-id="${editingQuestionId}"]`);
                    if (existingQuestionItem) {
                        const questionIndex = Array.from(questionListDiv.children).indexOf(existingQuestionItem) + 1;
                        existingQuestionItem.innerHTML = createQuestionHtml(updatedQuestion, questionIndex);
                    }
                } else {
                    const newQuestionHtml = `
                        <div class="question-item" draggable="true" data-question-id="${updatedQuestion.id}">
                            ${createQuestionHtml(updatedQuestion, questionListDiv.children.length + 1)}
                        </div>
                    `;
                    if (questionListDiv.querySelector('p') && questionListDiv.querySelector('p').innerText.includes('No questions added yet')) {
                        questionListDiv.innerHTML = newQuestionHtml; // Replace the "no questions" message
                    } else {
                        questionListDiv.insertAdjacentHTML('beforeend', newQuestionHtml);
                    }
                }
                resetForm(); // Clear form and reset buttons
                updateQuestionIndexes(); // Re-index all questions
            } else {
                const errorData = await response.json();
                alert('Error ' + (editingQuestionId ? 'updating' : 'adding') + ' question: ' + (errorData.error || response.statusText));
            }
        }

        async function editQuestion(questionId) {
            const response = await fetch(`/api/surveys/${surveyId}/questions/${questionId}`);
            if (response.ok) {
                const question = await response.json();
                editingQuestionId = question.id;

                questionTextElem.value = question.text;
                questionTypeElem.value = question.type;
                questionOptionsElem.value = question.options.join('\n');
                validationRulesElem.value = JSON.stringify(question.validation, null, 2);
                branchingLogicElem.value = JSON.stringify(question.branching_logic, null, 2);
                toggleOptionsInput(); // Ensure options section visibility is correct

                formTitleElem.textContent = 'Edit Question';
                submitQuestionBtn.textContent = 'Update Question';
                cancelEditBtn.style.display = 'inline-block';
            } else {
                alert('Error fetching question for editing.');
            }
        }

        function cancelEdit() {
            resetForm();
        }

        async function deleteQuestion(buttonElement, questionId) {
            if (!confirm('Are you sure you want to delete this question?')) {
                return;
            }

            const response = await fetch(`/api/surveys/${surveyId}/questions/${questionId}`, {
                method: 'DELETE',
            });

            if (response.ok) {
                alert('Question deleted successfully!');
                // Remove the question item from the DOM
                const questionItem = buttonElement.closest('.question-item');
                if (questionItem) {
                    questionItem.remove();
                }
                // If no questions left, show the "no questions" message
                if (questionListDiv.children.length === 0) {
                    questionListDiv.innerHTML = '<p>No questions added yet. Use the form below to add your first question.</p>';
                }
                updateQuestionIndexes(); // Re-index all questions
            } else {
                const errorData = await response.json();
                alert('Error deleting question: ' + (errorData.error || response.statusText));
            }
        }

        function createQuestionHtml(question, index) {
            return `
                <h3>${index}. ${question.text} (${question.type})</h3>
                <p><strong>Validation:</strong> ${JSON.stringify(question.validation)}</p>
                ${question.options.length > 0 ? `<p><strong>Options:</strong> ${question.options.join(', ')}</p>` : ''}
                ${Object.keys(question.branching_logic).length > 0 ? `<p><strong>Branching Logic:</strong> ${JSON.stringify(question.branching_logic)}</p>` : ''}
                <div class="actions">
                    <button onclick="editQuestion(${question.id})">Edit</button>
                    <button onclick="deleteQuestion(this, ${question.id})">Delete</button>
                </div>
            `;
        }

        function updateQuestionIndexes() {
            Array.from(questionListDiv.children).forEach((item, index) => {
                // Ensure it's a question item, not the "no questions" paragraph
                if (item.classList.contains('question-item')) {
                    const h3 = item.querySelector('h3');
                    if (h3) {
                        const text = h3.textContent;
                        // Regex to replace the leading number and dot
                        const newText = `${index + 1}. ${text.replace(/^\d+\.\s*/, '')}`;
                        h3.textContent = newText;
                    }
                }
            });
        }

        // --- Drag and Drop Functionality ---
        let draggedItem = null;

        questionListDiv.addEventListener('dragstart', (e) => {
            if (e.target.classList.contains('question-item')) {
                draggedItem = e.target;
                setTimeout(() => draggedItem.classList.add('dragging'), 0);
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', draggedItem.dataset.questionId); // Set data for Firefox
            }
        });

        questionListDiv.addEventListener('dragover', (e) => {
            e.preventDefault(); // Allow drop
            const afterElement = getDragAfterElement(questionListDiv, e.clientY);
            const draggable = document.querySelector('.dragging');
            if (draggable && afterElement) {
                questionListDiv.insertBefore(draggable, afterElement);
            } else if (draggable && !afterElement && questionListDiv.children.length > 0 && !questionListDiv.querySelector('p')) {
                // If no afterElement and there are existing items, append to end
                questionListDiv.appendChild(draggable);
            } else if (draggable && questionListDiv.children.length === 0 || (questionListDiv.children.length === 1 && questionListDiv.querySelector('p'))) {
                // If the list is empty or only contains the "no questions" message
                if (questionListDiv.querySelector('p')) {
                    questionListDiv.querySelector('p').remove(); // Remove "no questions" message
                }
                questionListDiv.appendChild(draggable);
            }
        });

        questionListDiv.addEventListener('dragleave', (e) => {
            // Optional: visual feedback when dragging leaves the container
        });

        questionListDiv.addEventListener('drop', async (e) => {
            e.preventDefault();
            if (draggedItem) {
                draggedItem.classList.remove('dragging');
                draggedItem = null;

                // Get the new order of question IDs
                const newOrderIds = Array.from(questionListDiv.querySelectorAll('.question-item'))
                                       .map(item => parseInt(item.dataset.questionId));

                // Send the new order to the backend
                const response = await fetch(`/api/surveys/${surveyId}/reorder_questions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ question_ids: newOrderIds }),
                });

                if (response.ok) {
                    alert('Questions reordered successfully!');
                    updateQuestionIndexes(); // Update visual numbering
                } else {
                    const errorData = await response.json();
                    alert('Error reordering questions: ' + (errorData.error || response.statusText));
                    // Optionally, revert the UI order if backend reorder failed
                    location.reload(); // Simple revert by reloading page
                }
            }
        });

        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.question-item:not(.dragging)')];

            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: -Infinity }).element;
        }

        // Initial options section visibility and form reset
        document.addEventListener('DOMContentLoaded', () => {
            toggleOptionsInput();
            resetForm(); // Ensure form is clean on load
            updateQuestionIndexes(); // Ensure initial numbering is correct
        });
    </script>
</body>
</html>
